PARA EL FINDE
	-terminar el script
	-buscar alguana forma de procesar el csv
	-añadir un parametro de opcion (--head o-h)
	-Buscar baeldon tn,awk,...
	-humanize time
		{
			<dependency>
    <groupId>com.github.mfornos</groupId>
    <artifactId>humanize-slim</artifactId>
    <version>1.2.2</version>
</dependency>

	EN LA CLASE
	import humanize.Humanize;
	int tiempo = 60;  // tiempo en minutos

        String resultado = Humanize.duration(tiempo * 60); en segundos
	
	
	
	-lambda
	-plugin Jpa buggi

LOS RECORDS NO PERMITEN HERENCIA
Ver Json views
Ver @JsonIgnore

para casa comando:npm i -g typescript
crear un proyecto de angular ng new [nombre del rpoyecto]
meter angular botstrap
crear modulo ng g m [nombre]
importar formsmodul en el app
------------------------------------
PREGUNTAR A LUISMI
como hacer el dto o el servicio para cuando una bicicleta este en uso o cuando no este en uso
como hacer lo mismo pero para cuando sea el findByid de bicicleta para la lista de usuario y la de uso
----------------APUNTES ANGULAR-------------------------------	
comando angular materials ng add angular/material
visual studio: jhonpapa
*ngif: es un if en el html del componente; *ngIf="edad"<18//*ngIf="ismenordeEdad()"
-------------------------------------------------
Acceso a datos
en una asociacion de oneToMany hay que poner mappedBy=""
es decir 
Alumno 1..*  -----------------> 1 Cursoos

-------Almuno----------------        --------------Cursos--------------
@ManyToOne
Cursos curso                 |	     |  @oneToMany(mappedBy="curso")
			     |	     |  List<Alumno> alumnos
			     |


fetch(eager,lazy)-Select (n+1)
		-Subselect
		-Join (join fetch)-Consultas explicitas
				-Grafos de entidad

LOS METODOS HELPERS SE PONEN EN EL LADO PROPIETARIO
Los metodos helper lo ponemos en el lado que no tiene el mappedBy

Helpers = bidireccional-oneToMany
			-ManyToOne-OneToMany
			-ManyToMany

los metodos helpers de una bidireccional
por ejemplo de usuario a producto:

addFavorito(Producto p){
this.getFavoritos().add(p);
p.getUsuarios().add(this);
}
--------------------------------------------------------------------			
****DOCKER****
Borrar todas las imagenes: docker rmi alpine
Añadir imagenes: docker pull alpine
Añadir un contenedor: docker run [nombre imagen]
Eliminar contenedor:docker rm [nombre del contenedor]
Docker run --name wp1 -d -p 8080:80 wordpress
y despues en el navegador ponemos localhost:8080
Docker ps -a para ver los que se esta ejecutando
Parar un contenedor: docker stop [nombre del contenedor]
Para hacer un reinicio : docker restart wp1
 docker run alpine cat /etc/os-release
docker run alpine/git --version
docker run --name mialpine alpine
docker run -it --name alpinec alpine -> (cuando te ponga el # ese) apk add nano 
Borrar todo:docker rm $(docker ps -aq)

crear un contenedor de pgadmin ESTE ES EL QUE PIDE PARA LOS EXAMENES: docker run --name pgadmin -d -p 5050:80 -e PGADMIN_DEFAULT_EMAIL=perez.almig23@triana.salesianos.edu -e PGADMIN_DEFAULT_PASSWORD=12345678 dpage/pgadmin4
docker run ubuntu /usr/bin/top -b -> como un administrador de tareas
para poder inicar la makina virtual:docker run -dit --rm --name topdemo1 ubuntu /usr/bin/top -b
crea un contenedor basado en ubunto no te apropies de mi terminal elimina el contenedor cuando salga de ese contenedor ...(lo que signifca)
luego:docker run topdemo1
una maquina virtual:docker exec -it topdemo1 /bin/bash

VER APARTADO PARTA CASA HOY 7.7
SINTAXIS DE DOCKER RUN
docker (opciones que se le puede dar) run [nombre de una imgen] (comando que se ejecuta al crear el contenedor)
docker run alpine cat /etc/os-release lo que hace es ver la version que tenemos instalada despues de crear el contendor con la imagen de alpine

Las opciones que hemos visto ;
options: --name = damos un nombre
	-d que no se apropie de la terminal y aparte te da un id ( se ejecuta en segundo plano)
	--rm al parar el contenedor se elimina automaticamente
	-p hacer parejas de puerto al host
	-i conectar la entrada estandar ak contenedor
	-t crea un terminar (seudo terminal) con linux 
	-e listar variables de entorno
Con docker attach nos podemos conectar al contenedor gracias al -b
docker attach topdemo1 => y sale como que esta conectado gracias a esto:docker run -dit --rm --name topdemo1 ubuntu /usr/bin/top -b
docker log para mostrar la traza que sigue el contenedor
docker run --rm --name alpine curl [ip]=172.17.0.3  <-
docker inspect httpdc | grep IPAddres para ver la ip |
para saber a que puerto esta asociado : docker inspect [nombre del contenedor]

---------------------------------------------------------------------
-+-+-+-+-+-+-+-+-+-+-+-+--+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
----------------------------------------------------------------------
****TIPOS DE HERENCIAS:*****

*******MAPPED SUPER CLASS*******
no es entidad
no permitia consultas polimorfica. es decir desde la padre podemos ver si un vehiculo es un coche o un camion ...
la clase padre es abstracta normalmente.
la clase no va a la base de datos va la hija .
repositorio solo de las hijas

*******SINGLE TABLE*******
unica tabla
@discriminator/colum/value/formula
la base puede ser o no abstracta
repositorios de la
consultas polimorfica
repositorio de la base es suficiente ( porque son consultas polimorficas)

*******JOINED*******
tantas tablas como entidades
una fk para cada hija-padre
@primarykeyjoincolumn(...)
repositorio para cada entidad

*******TABLE PER CLASS*******
no hay foreinkey
una tabla por entidad
UNION para una consulta 
(no se usa apenas)
para evitar los jooined de las consultas

REPASO CONSULTAS DEL AÑO PASADO
Spring data jpa: ->@query
		->consultas deribadas por el nombre de los metodos es decir podemos poner una consulta de sql en el nombre del metodo, estas consultas se llaman consultas derived 
		y spring data jpa se encarga de traducirla a sql por ejemplo findByApellidosAndNombre(string nombre, string apellidos),findFirstBy...OrderBy....(...)=> en este caso devuelve un optinal
		(estos ejemplos son con una sola entidad,pero podemos hacerlo con varias entidades como por ejemplo)
		(en este caso suponemos que estamos en el repositorio alumno lo que queremos es buscar en alumno por el nombre del curso)
		findByCursoNombre(string nombre)
	
Consultas jpql:
select a from Alumno a 
where a.fechaNacimiento = ?1/:[un_nombre]; podemos utilizar la triple comillas para poder hacer la consulta en varias lineas, luego para pasar parametros lo podemos poner con el ?1 y este se utiliza para el 
parametro 1 si fuera ?2 esparar el segundo parametro o se puede dar con : y un numbre 
(el nombre tiene que ser con barra baja es decir si es nomnbre compuesto tiene que ser fecha_nacimiento). 
el a.fechaNaciomiento no hay que llamarlo como se llame en la base de datos se llama con camelCase es decir asi: fecha_nacimiento.

QUEREMOS OBTENER ESTANDO EN EL REPO CURSO LOS ALUMNOS DE 2ºDAM siendo la entidad tipo LAZY=>
select c from Curso c 
joinfetch c.alumnos
where c.nombre = ?1
sin el joinfetch daria un error de tipo lazy . La consulta lo que mostraria seria los alumnos por el nombre de los alumnos por eso ponemos = ?1 porque lo que queremos pasar es el nombre del curso
ESTE ES EL MODELO DE DATOS DE ESTE EJEMPLO:
Curso:	|	    |Alumno
-id	|	    |-id
-nombre	|1-------1.*|-nombre
-tutor	|	    |-apellidos	     
-alumnos|           |-fec_nac
	|	    |-curso







